plugins {
    id 'java'
    id 'jacoco'
    id 'signing'
    id 'com.vanniktech.maven.publish' version '0.29.0' apply false
    id 'pl.allegro.tech.build.axion-release' version '1.17.0'
}

// Integration tests share a single Redis instance by default; serialize integrationTest tasks across modules
// even when Gradle parallel project execution is enabled (org.gradle.parallel=true).
abstract class SharedRedisIntegrationTestService implements org.gradle.api.services.BuildService<org.gradle.api.services.BuildServiceParameters.None>, AutoCloseable {
    @Override
    void close() {}
}

def sharedRedisIntegrationTestService = gradle.sharedServices.registerIfAbsent("sharedRedisIntegrationTestService", SharedRedisIntegrationTestService) {
    maxParallelUsages = 1
}

// Configure axion-release to derive version from git tags like `v1.2.3`
scmVersion {
    tag {
        prefix = 'v'
        // default versionSeparator is empty, so tags look like v1.2.3
    }
}

// Set project version early (root), subprojects will inherit
version = (findProperty('version') ?: scmVersion.version)

allprojects {
    group = 'io.github.cuihairu.redis-streaming'

    repositories {
        // Prefer mirrored repositories to avoid TLS/proxy issues resolving artifacts (e.g., JaCoCo agent)
        maven { url = 'https://maven.aliyun.com/repository/public' }
        maven { url = 'https://maven.aliyun.com/repository/central' }
        maven { url = 'https://mirrors.cloud.tencent.com/nexus/repository/maven-public/' }
        maven { url = 'https://repo.huaweicloud.com/repository/maven/' }
        // Fallback to central
        mavenCentral()
        // Optional
        mavenLocal()
    }
}

subprojects {
    apply plugin: 'java'
    apply plugin: 'jacoco'
    apply plugin: 'signing'
    // Only publish real modules; exclude example module from publishing
    if (project.name != 'examples') {
        apply plugin: 'com.vanniktech.maven.publish'
    }

    java {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
        withSourcesJar()
        // Do not explicitly call withJavadocJar() to avoid duplicate 'javadoc' artifacts when
        // using Vanniktech's maven-publish. The plugin wires javadocJar for Java projects.
    }

    tasks.withType(JavaCompile).configureEach {
        options.encoding = 'UTF-8'
        // Enable deprecation lint and treat warnings as errors; suppress unchecked warnings
        options.compilerArgs += ['-Xlint:deprecation', '-Xlint:unchecked', '-Werror']
        options.deprecation = true
        // Compile against Java 17 API even when using newer JDKs locally (e.g., JDK 21)
        if (JavaVersion.current().isCompatibleWith(JavaVersion.VERSION_17)) {
            options.release = 17
        }
    }

    // Tests should not fail compilation due to deprecation warnings (allow @Deprecated usage in tests)
    tasks.withType(JavaCompile).configureEach { t ->
        if (t.name.toLowerCase().contains('test')) {
            t.options.compilerArgs = t.options.compilerArgs.findAll { it != '-Werror' }
        }
    }

    dependencies {
        testImplementation 'org.junit.jupiter:junit-jupiter:5.9.2'
        testImplementation 'org.junit.jupiter:junit-jupiter-api:5.9.2'
        testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.9.2'
    }

    // Configure source sets for integration tests
    sourceSets {
        integrationTest {
            java {
                srcDir 'src/test/java'
            }
            resources {
                srcDir 'src/test/resources'
            }
            compileClasspath += sourceSets.main.output + sourceSets.test.output
            runtimeClasspath += sourceSets.main.output + sourceSets.test.output
        }
    }

    // Configure integration test dependencies
    configurations {
        integrationTestImplementation.extendsFrom testImplementation
        integrationTestRuntimeOnly.extendsFrom testRuntimeOnly
        integrationTestCompileOnly.extendsFrom testCompileOnly
        integrationTestAnnotationProcessor.extendsFrom testAnnotationProcessor
    }

    // Unit tests: exclude integration tests
    tasks.named('test') {
        useJUnitPlatform {
            excludeTags 'integration'
        }
        description = 'Runs unit tests (excludes integration tests that require Redis)'
        group = 'verification'
    }

    // Integration tests: only run integration tests
    tasks.register('integrationTest', Test) {
        useJUnitPlatform {
            includeTags 'integration'
        }
        testClassesDirs = sourceSets.integrationTest.output.classesDirs
        classpath = sourceSets.integrationTest.runtimeClasspath

        description = 'Runs integration tests (requires Redis to be running)'
        group = 'verification'

        shouldRunAfter test

        // Prevent cross-module interference when running integration tests in parallel against a shared Redis.
        usesService(sharedRedisIntegrationTestService)

        // Configure to show more output
        testLogging {
            events "passed", "skipped", "failed"
            exceptionFormat "full"
            showStandardStreams = false
        }
    }

    // Add integrationTest to check task
    tasks.named('check') {
        dependsOn integrationTest
    }

    // javadocJar is enabled to satisfy Central Portal best practices

    // Maven Central publishing via Vanniktech (Central Portal)
    if (plugins.hasPlugin('com.vanniktech.maven.publish')) {
    mavenPublishing {
        publishToMavenCentral(com.vanniktech.maven.publish.SonatypeHost.CENTRAL_PORTAL)
        signAllPublications()
        coordinates(group, project.name, version)
        pom {
            // Default name/description; will be overridden for key modules below
            name.set(project.name)
            description.set("Streaming Processing Framework - ${project.name} module")

            // Friendlier names/descriptions for key modules (display-only; artifactId remains project.name)
            if (project.name == 'core') {
                name.set('redis-streaming core')
                description.set('Core abstractions and API')
            } else if (project.name == 'runtime') {
                name.set('redis-streaming runtime')
                description.set('Stream processing engine runtime')
            } else if (project.name == 'spring-boot-starter') {
                name.set('redis-streaming spring-boot-starter')
                description.set('Spring Boot starter for redis-streaming')
            }
            url.set('https://github.com/cuihairu/redis-streaming')
            licenses {
                license {
                    name.set('The Apache License, Version 2.0')
                    url.set('https://www.apache.org/licenses/LICENSE-2.0.txt')
                }
            }
            scm {
                connection.set('scm:git:https://github.com/cuihairu/redis-streaming.git')
                developerConnection.set('scm:git:ssh://git@github.com/cuihairu/redis-streaming.git')
                url.set('https://github.com/cuihairu/redis-streaming')
            }
            developers {
                developer {
                    id.set('cuihairu')
                    name.set('Cui Hairu')
                    email.set('chuihairu@gmail.com')
                }
            }
            issueManagement {
                system.set('GitHub Issues')
                url.set('https://github.com/cuihairu/redis-streaming/issues')
            }
        }
    }
    }

    // Signing handled by Vanniktech via signAllPublications()

    // Generate Javadoc
    tasks.withType(Javadoc) {
        options.encoding = 'UTF-8'
        options.charSet = 'UTF-8'
        options.author = true
        options.version = true
        options.links = [
            'https://docs.oracle.com/en/java/javase/17/docs/api/'
        ]
        // Suppress warnings and errors for Lombok generated code
        options.addStringOption('Xdoclint:none', '-quiet')
        options.addBooleanOption('Xdoclint:none', true)
        // Ignore errors to allow Lombok-generated code references
        failOnError = false
    }
}

// Aggregate coverage across subprojects
tasks.register('jacocoRootReport', JacocoReport) {
    // Depend only on unit tests; integration tests require Redis and should not be pulled in by coverage.
    // (If integration tests already ran, their .exec files will still be picked up via executionData.)
    dependsOn subprojects.collect { it.tasks.named('test') }
    // If integration tests are already in the task graph (e.g., `check`), prefer generating reports after them
    // so their execution data can be included.
    shouldRunAfter subprojects.collect { it.tasks.named('integrationTest') }
    additionalSourceDirs.from files(subprojects.collect { it.file('src/main/java') })
    sourceDirectories.from files(subprojects.collect { it.file('src/main/java') })
    classDirectories.from files(subprojects.collect { fileTree(dir: "${it.buildDir}/classes/java/main") })
    executionData.from files(subprojects.collect { fileTree(dir: it.buildDir, includes: ['jacoco/*.exec']) })
    doFirst {
        executionData.files.removeIf { !it.exists() }
    }
    reports {
        xml.required = true
        html.required = true
    }
}

tasks.register('jacocoRootCoverageVerification', JacocoCoverageVerification) {
    // Depend only on unit tests; integration tests require Redis and should not be pulled in by coverage.
    // (If integration tests already ran, their .exec files will still be picked up via executionData.)
    dependsOn subprojects.collect { it.tasks.named('test') }
    // If integration tests are already in the task graph (e.g., `check`), prefer verifying after them
    // so their execution data can be included.
    shouldRunAfter subprojects.collect { it.tasks.named('integrationTest') }
    executionData.from files(subprojects.collect { fileTree(dir: it.buildDir, includes: ['jacoco/*.exec']) })
    classDirectories.from files(subprojects.collect { fileTree(dir: "${it.buildDir}/classes/java/main") })
    doFirst { executionData.files.removeIf { !it.exists() } }
    violationRules {
        rule {
            limit {
                counter = 'INSTRUCTION'
                value = 'COVEREDRATIO'
                minimum = 0.25
            }
        }
    }
}

tasks.named('check') {
    dependsOn tasks.named('jacocoRootCoverageVerification')
}

// Helper task: sanity-check presence of Central Portal credentials (does not print secrets)
tasks.register('checkCentralPortalCreds') {
    group = 'publishing'
    description = 'Prints whether Central Portal credentials are detectable via env or Gradle properties.'
    doLast {
        def envUser = System.getenv('CENTRAL_PORTAL_USERNAME') != null
        def envPass = System.getenv('CENTRAL_PORTAL_PASSWORD') != null
        def propUser = providers.gradleProperty('centralPortalUsername').getOrNull() != null
        def propPass = providers.gradleProperty('centralPortalPassword').getOrNull() != null
        def propMcUser = providers.gradleProperty('mavenCentralUsername').getOrNull() != null
        def propMcPass = providers.gradleProperty('mavenCentralPassword').getOrNull() != null
        println("CENTRAL_PORTAL_USERNAME present (env): ${envUser}")
        println("CENTRAL_PORTAL_PASSWORD present (env): ${envPass}")
        println("centralPortalUsername present (gradle.properties/-P): ${propUser}")
        println("centralPortalPassword present (gradle.properties/-P): ${propPass}")
        println("mavenCentralUsername present (gradle.properties/-P): ${propMcUser}")
        println("mavenCentralPassword present (gradle.properties/-P): ${propMcPass}")
    }
}
